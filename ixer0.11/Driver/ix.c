/*++

Copyright (c) 2012-2013 XenoStudio. All Rights Reserved.

Module Name:

    ix.c

Abstract:

    This framework is generated by QuickSYS 0.4

Author:

	Chinghoi[X.S.T]

Environment:

	Kernel mode only.

Revision History:

	build:
		Aug 11，2012
	revision:
		Jan 28，2013

	N.B.
	__except_handler4 is used by VC8 if BufferSecurityCheck(/GS) is on, supported by WDK.
	Turn it off when using old DDK and VC8 will use __except_handler3.

	If BufferSecurityCheck(/GS) is on, change entry point to GsDriverEntry@8 and add BufferOverflowK.lib.

	For x64, change _X86_=1 to _AMD64=1, include directory to ddk\wnet, lib path to lib\wnet\amd64.

--*/

#include "precomp.h"
#include "drvMod.h"
#include "..\Common\Surface.h"
#include "..\Common\ioctl.h"
#include "Init.h"
#include "ix.h"


extern PDRIVER_OBJECT g_IxDrvObject;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, IrpMjXTRdevCtrlRoutine)
#pragma alloc_text(PAGE, IrpMjXTRUnloadRoutine)
#endif // ALLOC_PRAGMA



/*========================================================================
*
* 函数名:	DriverEntry
*
* 参数:		PDRIVER_OBJECT	[IN] DriverObject
*			PUNICODE_STRING	[IN] RegistryPath
*
* 功能描述:	驱动入口函数
*
* 返回值:	NTSTATUS
*
=========================================================================*/
NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	NTSTATUS			status;    
    UNICODE_STRING		ntDeviceName;
	UNICODE_STRING		dosDeviceName;
    PDEVICE_EXTENSION	deviceExtension;
	PDEVICE_OBJECT		deviceObject = NULL;
	BOOLEAN				symbolicLink = FALSE;

    dprintf("[$XTR] DriverEntry(0x%08x, RegistryPath:%wZ)\n", DriverObject, RegistryPath);
	//////////////////////////初始化驱动设备系统/////////////////////////////////
	if ( !NT_SUCCESS( status = InitMySystem() ))
		return status;

    //
    // TODO:
    //
    //     1. Report it's resources (IoReportResourceUsage)
    //
    //     2. Attempt to locate the device(s) it supports
	//

    RtlInitUnicodeString(&ntDeviceName, IXER_DEVICE_NAME_W);

	/*创建设备对象*/
    status = IoCreateDevice(
				DriverObject,
				sizeof(DEVICE_EXTENSION),		// DeviceExtensionSize
				&ntDeviceName,					// DeviceName
				FILE_DEVICE_UNKNOWN,			// DeviceType
				0,								// DeviceCharacteristics
				TRUE,							// Exclusive
				&deviceObject					// [OUT]
				);

	if (!NT_SUCCESS(status))
	{
		dprintf("[$XTR] IoCreateDevice failed(0x%x).\n", status);
		goto failed;
	}

	g_IxDrvObject=DriverObject;
	//设置设备的读写模式
	deviceObject->Flags |= DO_BUFFERED_IO;	//缓冲区读写
	//设置设备的扩展数据
	deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

	//
	// TODO: set up synchronization objects, state info,, etc.
	//

    RtlInitUnicodeString(&dosDeviceName, IXER_DOS_DEVICE_NAME_W);

	/*创建符号链接*/
    status = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);
    if ( !NT_SUCCESS(status) )
    {
        dprintf("[$XTR] IoCreateSymbolicLink failed(0x%x).\n", status);
		goto failed;
    }

	symbolicLink = TRUE;

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = 
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = 
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpMjXTRdevCtrlRoutine;
    DriverObject->DriverUnload                         = IrpMjXTRUnloadRoutine;

    if (NT_SUCCESS(status))
	    return status;

failed:

	if (symbolicLink)
		IoDeleteSymbolicLink(&dosDeviceName);	//删除符号链接

	if (deviceObject)
		IoDeleteDevice(deviceObject);			//删除设备对象

	return status;
}

/*========================================================================
*
* 函数名:	IrpMjXTRdevCtrlRoutine
*
* 参数:		PDEVICE_OBJECT	[IN] DeviceObject
*			PIRP			[IN] Irp
*
* 功能描述:	驱动派遣例程
*
* 返回值:	NTSTATUS
*
=========================================================================*/
NTSTATUS
IrpMjXTRdevCtrlRoutine(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS			status = STATUS_SUCCESS;				//默认返回值、状态
	PIO_STATUS_BLOCK	ioStatus;								//IRP的IO状态
    PIO_STACK_LOCATION	pIrpStack;								//当前的IRP栈
    PDEVICE_EXTENSION	deviceExtension;
	PVOID				inputBuffer, outputBuffer;				//输入、输出缓冲区
	ULONG				inputBufferLength, outputBufferLength;	//输入、输出缓冲区的大小
	ULONG				ioControlCode;

/*	dprintf("[$XTR]--->IrpMjXTRdevCtrlRoutine( 0x%08x, 0x%08x ).\n", DeviceObject, Irp);*/

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	ioStatus = &Irp->IoStatus;
	ioStatus->Status      = STATUS_SUCCESS;	// Assume success
	ioStatus->Information = 0;              // Assume nothing returned

    //
    // Get the pointer to the input/output buffer and it's length
    //

    inputBuffer			= Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength	= pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	outputBuffer		= Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength	= pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode		= pIrpStack->Parameters.DeviceIoControl.IoControlCode;

	switch (pIrpStack->MajorFunction)
	{
	case IRP_MJ_CREATE:
		dprintf("[$ixer]<-IRP_MJ_CREATE.\n");
		break;

	case IRP_MJ_CLOSE:
		dprintf("[$ixer]->IRP_MJ_CLOSE.\n");
		break;

	case IRP_MJ_SHUTDOWN:
		dprintf("[$ixer] IRP_MJ_SHUTDOWN.\n");
		break;

	case IRP_MJ_DEVICE_CONTROL:
		if (IOCTL_TRANSFER_TYPE(ioControlCode) == METHOD_NEITHER)
		{
			dprintf("[$ixer] METHOD_NEITHER\n");
			outputBuffer = Irp->UserBuffer;
		}

	//
	dprintf("[$XTR] IRP_MJ_DEVICE_CONTROL->IrpMjXTRdevCtrlRoutine(DeviceObject=0x%08x, Irp=0x%08x)->IxioControl().\n", DeviceObject, Irp);
	//io控制函数
	IxioControl( inputBuffer,			//输入缓冲区
				  inputBufferLength,		//输入缓冲区大小
				  outputBuffer,			//输出缓冲区
				  outputBufferLength,		//输出缓冲区大小
				  ioControlCode,		//功能号
				  ioStatus);				//IRP的IO状态
		break;
	}

	//
	// TODO: if not pending, call IoCompleteRequest and Irp is freed.
	//

	Irp->IoStatus.Status = ioStatus->Status;
	Irp->IoStatus.Information = ioStatus->Information;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

//	dprintf("[$XTR] IrpMjXTRdevCtrlRoutine() pIoStatus=0x%08x\n", Irp->IoStatus.Status);
    return status;
}

/*========================================================================
*
* 函数名:	IrpMjXTRUnloadRoutine
*
* 参数:		PDRIVER_OBJECT	[IN] DriverObject
*
* 功能描述:	驱动卸载例程
*
* 返回值:	VOID
*
=========================================================================*/
VOID
IrpMjXTRUnloadRoutine(
	IN PDRIVER_OBJECT		DriverObject
	)
{
    UNICODE_STRING dosDeviceName;
	int		i;

	//
    // Free any resources
    //

    //
    // Delete the symbolic link
    //

    RtlInitUnicodeString(&dosDeviceName, IXER_DOS_DEVICE_NAME_W);
	//删除符号链接
    IoDeleteSymbolicLink(&dosDeviceName);

    //
    // Delete the device object
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    dprintf("[$ixer] unloaded..\n");
}